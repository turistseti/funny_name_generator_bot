#!/usr/bin/env python

import logging
import os
import random
import time

from telegram import Update
from telegram.ext import Updater, CommandHandler, CallbackContext

FIRST_NAMES = [
    'Подрыв',
    'Ушат',
    'Поджог',
    'Погром',
    'Обвал',
    'Угон',
    'Исход',
    'Захват',
    'Камаз',
    'Развод',
    'Удар',
    'Курган',
    'Загон',
    'Запой',
    'Разрез',
    'Разгул',
    'Разбор',
    'Учет',
    'Друган',
    'Улов',
    'Рулон',
    'Подшум',
    'Разгул',
    'Пиздабол',
    'Дружбан',
    'Вжбан',
    'Еблан',
    'Лажан',
    'Охуен',
    'Ёптить',
    'Ебун',
    'Парад',
    'Забой',
    'Мешок',
    'Карман',
    'Пакет',
    'Залог',
    'Залуп',
    'Отлуп',
    'Куколд',
    'Рукоблуд',
    'Гормон',
    'Хунан',
    'Хулинам',
    'Ахулинам',
    'Чувак',
    'Завали',
    'Пахан',
    'Глашатай',
    'Стояк'
]

SECOND_NAMES = [
    'Помоев',
    'Устоев',
    'Сараев',
    'Евреев',
    'Забоев',
    'Харлеев',
    'Изгоев',
    'Покоев',
    'Отходов',
    'Супругов',
    'Морозов',
    'Отбросов',
    'Баранов',
    'Гусаров',
    'Батонов',
    'Гормонов',
    'Полетов',
    'Расходов',
    'Братанов',
    'Кальмаров',
    'Обоев',
    'Прибоев',
    'Кисколизов',
    'Сувениров',
    'Крахмалов',
    'Охуеннов',
    'Приколов',
    'Данунахов',
    'Ебланов',
    'Ебашев',
    'Валенков',
    'Колотунов',
    'Подъебанов',
    'Лошпетов',
    'Уродов',
    'Баранов',
    'Лимонов',
    'Пистонов',
    'Гандонов',
    'Табунов',
    'Пиздоев',
    'Рукоблудов',
    'Дрочев',
    'Приколов',
    'Залупов',
    'Проёбов',
    'Затрахов',
    'Колотунов',
    'Задрищев',
    'Ичпочмаков',
    'Эпочмаков',
    'Разгуляев',
    'Расстегаев',
    'Невъебенов',
    'Ебало',
    'Ебалов',
    'Задрочев',
    'Задротов',
    'Уёбков',
    'Шакалов',
    'Колбасов',
    'Разрабов',
    'Барменов',
    'Разбоев',
    'Зелебобов',
    'Данунахов',
    'Сиськолизов',
    'Письколизов',
    'Нестоянов'
]


def gen_name():
    random.seed(time.time() / time.perf_counter() * time.process_time())
    first_name = random.choice(FIRST_NAMES)
    random.seed(len(first_name) * time.time() / time.perf_counter() * time.process_time())
    second_name = random.choice(SECOND_NAMES)
    return f'{first_name} {second_name}'


# включаем логгирование
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
logger = logging.getLogger(_name_)


# это обработчики команд (handler-ы). Обычно приниают вот эти два параметра, которые содержат нужный
# контекст, то есть необъодимые для нас переменные (типа, имени пользователя, его ID и так далее), и
# созданный нами движок (об этом ниже)

# вот обработчик команды /start. Когда пользователь вводит /start, вызывается эта функция
# то же самое происходит, если пользователь выберет команду start из списка команд (это
# сделаем позже в BotFather)
def generate_name(engine: Update, context: CallbackContext) -> None:
    print('generate_name()')
    engine.message.reply_text(gen_name(), reply_to_message_id=None)


# другой обработчик - для команды /help. Когда пользователь вводит /help, вызывается этот код
def help_command(engine: Update, context: CallbackContext) -> None:
    # отправляем какой-то стандартный жестко заданный текст
    engine.message.reply_text('Помощь!')


def echo(engine: Update, context: CallbackContext) -> None:
    # вызываем команду отправки сообщения пользователю, используя
    # при это текст сообщения, полученный от пользователя
    engine.message.reply_text(engine.message.text)


def main() -> None:
    # создаем объект фреймворка (библиотеки) для создания телеграм-ботов, с помощью
    # которого мы сможем взаимодействовать с фреймворком, то есть тот связующий объект,
    # через который мы будем общаться со всеми внутренностями (которые делают основную
    # работу по отправке сообщений за нас) фреймворка. Причем, общаться будем в обе стороны:
    # принимать сообщения от него и задавать параметры для него
    #
    # я назвал его engine (движок), чтобы было понятнее. В самой либе (библиотеке, фреймворке)
    # он называется Updater, как видно, что немного запутывает
    engine = Updater(os.getenv('DP_TG_BOT_TOKEN'))

    # получаем объект "передатчика" или обработчика сообщений от нашего движка
    dispatcher = engine.dispatcher

    # тут "связываем" наши команды и соответствующие им обработчики (хендлеры);
    # иногда говорят "повесить коллбэк" (коллбэк это то же самое что и обработчики (они же хендлеры),
    # то есть та функция, которая вызывается в ответ на какое-то событие: callback, то есть
    # call back - дословно, что-то вроде вызвать обратно, то есть наша функция, которую мы передали,
    # вызовется позже в ответ на какое-то событие; в нашем случае они будут вызываться тогда, когда
    # пользователь будет выбирать соответствующие команды
    dispatcher.add_handler(CommandHandler("generate", generate_name))
    dispatcher.add_handler(CommandHandler("help", help_command))

    # говорим обработчику сообений, чтобы он вызывал функцию echo каждый раз,
    # когда пользователь отправляем боту сообщение
    #
    # про параметр 'Filters.text & ~Filters.command' можно пока не заморачиваться;
    # он означает, что функция echo будет вызываться только тогда, когда пользователь
    # ввел именно текст, а не команду; в противном случае, если пользователь введет
    # команду /start или /help, эта функция будет вызвана, что нам не нужно
    # dispatcher.add_handler(MessageHandler(Filters.text & ~Filters.command, echo))
    # dispatcher.add_handler(MessageHandler(Filters.user("@russian_name_generator_bot"), generate_name))

    # непосредственно старт бота
    engine.start_polling()

    # говорим боту работать, пока не нажмем Ctrl-C или что-то не сломается само :)
    engine.idle()


if _name_ == '_main_':
    main()
